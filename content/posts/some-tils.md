---
title: "Some TILs:"
date: 2024-12-22T05:21:16-07:00
draft: false
tags: ["python", "crypto", "ai", "data-science"]
categories: ["Programming", "Data Science", "Technology"]
summary: "1. Ulysses pact: a freely made decision to bind yourself in the future. Used for "living wills" in modern day but originated from Greek…"
medium_url: "https://medium.com/@olshansky/some-tils-b25f8fe535ed"
---

**Some TILs:**

1. Ulysses pact: a freely made decision to bind yourself in the future. Used for “living wills” in modern day but originated from Greek mythology when trying to overcome circumstances that make you insane.

2. Scala: I remember the excitment around Scala in the early 2010s but never really looked into why it dided. One of the core contibutors (Paul Phillips) left in 2013. I also learnt that the founder, Martin Odersky, started working on Scala in 2001!

**Some TOLs:**

1. Why would anyone still be using the JVM i 2024!?

2. Not sure how I feel about a language with no loops and no ifs…

3. Gleam feels like it’s being led by a “languag maximilalists” rather than “language pragmitists” seeing how much deprecataion there is in the standard library already…

It’s interesting how different my personal language biases are....*

**A combination of my experience, what I use at work and what I use for side projects, my approach is:**

1. **Python: my initial goto**. Awesome for scripting, tooling, data science, llm-enabled projects and has a place on larger teams depending on the needs of the project.

2. **Golang: my bias when building backend services on a team**. It’s so opinionated, simple, easy to maintain, design and extend. It makes you think about usage and interface rather than syntax. Easy to learn, easy to hire for and attracts people who want to think about the end goal of the product rather than the code.

3. **Elixir: The easiest way to scale.** It’s been 4 years since I used it, but if I had to build a very scalabale backend server, I’d probably start with Go and move to Elixir when the time is right. The BEAM is a solid foundation and the Phoenix framework lets you ship.

4. **Rust: Never used it, but it has it's place in replacing C/C++.** If we really do need to go down the compile-time checks, and be TLA+ Connoisseurs, I’d probably go with rust. When it works, it’ll always work efficiently. It replaces C. I simply find that it attracts the wrong people (if you’re building a product) and not needed unless you’re optimizing things like low level cryptography.

**Questions for Chander:**

1. Have you ever used Elixir? Gleam looks like it was heavily inspired by it.

2. Why not use Golang instead of node for your day-to-day?

3. I understand the goal of AoC is not to use AI, but when it comes to searching for answers w.r.t the standard library, I think that’s fair game.
