<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Hot Reloading with Local Docker Development</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Hot Reloading with Local Docker Development</h1>
</header>
<section data-field="subtitle" class="p-summary">
tl;dr You can find the source code for a bare-bones dockerized python HTTP server with hot reloading using fastapi on this Github page.
</section>
<section data-field="body" class="e-content">
<section name="1549" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bc4c" id="bc4c" class="graf graf--h3 graf--leading graf--title">Hot Reloading with Local Docker Development</h3><p name="1bb0" id="1bb0" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">tl;dr You can find the source code for a bare-bones dockerized python HTTP server with hot reloading using fastapi on this Github page.</em></p><p name="3112" id="3112" class="graf graf--p graf-after--p">I recently came by this tweet:</p><figure name="0311" id="0311" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZP3vZwYuBqUM76zU--mlTQ.png" data-width="1222" data-height="510" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*ZP3vZwYuBqUM76zU--mlTQ.png"></figure><p name="b89e" id="b89e" class="graf graf--p graf-after--figure">While there are many reasons to have separate Docker images for your development and production environments, it may be overkill for a small project you’re just starting. Over the past several years, I’ve been using the <a href="https://docs.docker.com/storage/volumes/" data-href="https://docs.docker.com/storage/volumes/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">volume mounting</a> feature in order to:</p><ol class="postList"><li name="3990" id="3990" class="graf graf--li graf-after--p">Use the same Dockerfile for local development and production.</li><li name="62e0" id="62e0" class="graf graf--li graf-after--li">Test against a locally running docker container.</li><li name="5513" id="5513" class="graf graf--li graf-after--li graf--trailing">Have the docker container reflect changes I make to the source code on my host machine.</li></ol></div></div></section><section name="e0f8" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="5155" id="5155" class="graf graf--p graf--leading">Following the instructions at <a href="https://github.com/tiangolo/fastapi" data-href="https://github.com/tiangolo/fastapi" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">fastapi</a>, I’ve created a very simple python server:</p><figure name="6c89" id="6c89" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/87df83c4d42d9adfdcd3812e597fc49b.js"></script></figure><p name="5ba0" id="5ba0" class="graf graf--p graf-after--figure graf--trailing">The server can be started locally with <code class="markup--code markup--p-code">uvicorn src/main:app --reload</code> and tested with <code class="markup--code markup--p-code">curl -X GET http://localhost:8000</code>. Since we started the server with the <code class="markup--code markup--p-code">--reload</code> flag, modifying the return value of <code class="markup--code markup--p-code">read_root</code> will dynamically modify the return value from the http request.</p></div></div></section><section name="1ca8" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="d1cd" id="d1cd" class="graf graf--p graf--leading">In order to Dockerize our application, we add a Dockerfile and a docker-compose.yaml file:</p><figure name="537e" id="537e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/9b0bef1fe1a7e3b1eb99450b441950d3.js"></script></figure><figure name="f38e" id="f38e" class="graf graf--figure graf--iframe graf-after--figure"><script src="https://gist.github.com/c54fcc381779fd53fb8f4a128769673d.js"></script></figure><p name="ff17" id="ff17" class="graf graf--p graf-after--figure graf--trailing">The server can be started locally with <code class="markup--code markup--p-code">docker-compose up -d</code> and tested with <code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">curl -X GET <a href="http://localhost:8008." data-href="http://localhost:8008." class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">http://localhost:8008</a></code><a href="http://localhost:8008." data-href="http://localhost:8008." class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">.</a> Note how on line 5 of the Dockerfile, the source code is copied over from our local directory into the working directory of the docker image. However, if you modify the code locally, these changes will not be reflected inside the container and the image will need to be rebuilt.</p></div></div></section><section name="3ce7" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="b4b7" id="b4b7" class="graf graf--p graf--leading">The solution is quite simple. Simply add the following volume mount to your service definition in the docker compose file:</p><pre name="a2ce" id="a2ce" class="graf graf--pre graf-after--p">volumes:<br>      - ./src:/usr/src</pre><p name="9368" id="9368" class="graf graf--p graf-after--pre">The above command will override the COPY operation we did while building the image and have the code inside the container reflect any changes that were made on your local machine. The final docker-compose.yaml file will look like so:</p><figure name="c01a" id="c01a" class="graf graf--figure graf--iframe graf-after--p graf--trailing"><script src="https://gist.github.com/7ca3e5819102321974277255567f45ce.js"></script></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@olshansky" class="p-author h-card">Daniel Olshansky</a> on <a href="https://medium.com/p/1ec5dbaa4a65"><time class="dt-published" datetime="2020-07-19T21:01:38.446Z">July 19, 2020</time></a>.</p><p><a href="https://medium.com/@olshansky/hot-reloading-with-local-docker-development-1ec5dbaa4a65" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 13, 2025.</p></footer></article></body></html>